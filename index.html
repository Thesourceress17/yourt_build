<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>×‘×•× ×” ×”×™×•×¨×˜×” - ×”×’×¨×¡×” ×”××œ××”</title>
    <style>
        :root {
            --primary-color: #5D4037;
            --accent-color: #FFC107;
            --bg-sky: #81D4FA;
            --bg-grass: #66BB6A;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            background: linear-gradient(to bottom, var(--bg-sky) 50%, var(--bg-grass) 50%);
            display: flex;
            flex-direction: column;
            user-select: none;
            touch-action: none;
        }

        /* --- ×¨×§×¢ ×•×× ×™××¦×™×•×ª --- */
        .scenery { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        
        /* ×¢× × ×™× */
        .cloud {
            position: absolute; background: rgba(255,255,255,0.8); border-radius: 50px;
            animation: moveCloud linear infinite;
        }
        .cloud::after, .cloud::before { content: ''; position: absolute; background: inherit; border-radius: 50%; }
        
        .c1 { top: 40px; left: -100px; width: 100px; height: 40px; animation-duration: 45s; }
        .c1::after { top: -20px; left: 15px; width: 40px; height: 40px; }
        .c1::before { top: -15px; left: 40px; width: 50px; height: 50px; }

        .c2 { top: 80px; left: -150px; width: 120px; height: 50px; animation-duration: 60s; animation-delay: -20s; opacity: 0.6; }
        .c2::after { top: -25px; left: 20px; width: 50px; height: 50px; }
        
        @keyframes moveCloud { from { transform: translateX(0); } to { transform: translateX(120vw); } }

        /* ×—×™×•×ª */
        .animal { position: absolute; bottom: 52%; opacity: 0.9; transform: scaleX(-1); filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2)); }
        .horse { right: 15%; width: 70px; height: 60px; }
        .camel { left: 15%; width: 80px; height: 70px; transform: scaleX(1); }

        /* --- ×›×¤×ª×•×¨×™× --- */
        .controls { position: absolute; top: 20px; left: 20px; display: flex; gap: 10px; z-index: 500; }
        .btn {
            background: #fff; border: 2px solid var(--primary-color); color: var(--primary-color);
            padding: 8px 16px; border-radius: 20px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2); font-size: 14px;
        }
        .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.2); }

        /* --- ××–×•×¨ ××©×—×§ --- */
        #stage {
            position: relative; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            perspective: 1000px; z-index: 10;
        }
        #anchor-point { position: relative; width: 0; height: 0; top: 80px; }

        .part {
            position: absolute; left: 50%; top: 50%;
            transform: translate(-50%, -50%); opacity: 0; pointer-events: none;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: bottom center;
        }
        .part.visible { opacity: 1; }

        /* --- ×¡×¨×’×œ ×›×œ×™× --- */
        #sidebar {
            position: absolute; right: 0; top: 0; height: 100%; width: 110px;
            background: rgba(255,255,255,0.95); box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; align-items: center;
            padding-top: 20px; overflow-y: auto; gap: 15px; z-index: 400;
        }
        .tool {
            width: 90px; height: 90px; border: 2px dashed #ccc; border-radius: 12px;
            background: white; display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: grab; transition: all 0.2s; flex-shrink: 0; position: relative;
        }
        .tool:active { cursor: grabbing; }
        .tool.active {
            border: 2px solid var(--accent-color); background: #FFF8E1;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); transform: scale(1.05);
            animation: pulse-tool 1.5s infinite;
        }
        @keyframes pulse-tool { 0% { border-color: #FFC107; } 50% { border-color: #FF9800; } 100% { border-color: #FFC107; } }
        .tool.locked { opacity: 0.4; filter: grayscale(1); pointer-events: none; }
        .tool.done { border-color: #4CAF50; opacity: 0.7; pointer-events: none; }
        .tool.done::after {
            content: 'âœ“'; position: absolute; top: -5px; right: -5px; background: #4CAF50;
            color: white; border-radius: 50%; width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        .tool svg { width: 60px; height: 60px; pointer-events: none; }
        .tool span { font-size: 12px; margin-top: 5px; color: #333; font-weight: bold; text-align: center; }

        /* --- ×’×¨×™×¨×” --- */
        .drop-target {
            position: absolute; border: 4px dashed rgba(255, 235, 59, 0.8);
            background: rgba(255, 235, 59, 0.2); border-radius: 50%;
            transform: translate(-50%, -50%); opacity: 0; pointer-events: none;
            transition: all 0.3s; z-index: 100;
        }
        .drop-target.active { opacity: 1; animation: pulse-target 1s infinite alternate; }
        .drop-target.hover { background: rgba(255, 235, 59, 0.4); transform: translate(-50%, -50%) scale(1.1); }
        @keyframes pulse-target { from { border-color: rgba(255,235,59,0.5); } to { border-color: rgba(255,193,7,1); } }

        .drag-ghost {
            position: fixed; width: 80px; height: 80px; background: white;
            border: 2px solid var(--accent-color); border-radius: 10px;
            opacity: 0.9; pointer-events: none; z-index: 1000;
            display: flex; justify-content: center; align-items: center;
            transform: translate(-50%, -50%); box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        .drag-ghost svg { width: 60px; height: 60px; }

        #msg {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: white; padding: 12px 30px;
            border-radius: 30px; font-size: 18px; pointer-events: none;
            text-align: center; min-width: 300px; z-index: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* --- ×—×‘×œ×™× --- */
        #ropes-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 300;
        }
        .node {
            position: absolute; width: 22px; height: 22px;
            border-radius: 50%; border: 2px solid white;
            cursor: pointer; pointer-events: auto;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.4); z-index: 301;
        }
        .node.start { background: #333; animation: bounce 1s infinite alternate; } /* ×©×—×•×¨ ×œ× ×§×•×“×•×ª ×”×ª×—×œ×” */
        .node.end { background: rgba(0,0,0,0.3); border: 2px dashed #333; } /* ××–×•×¨ ×¡×™×•× ×©×§×•×£ ×œ××˜×” */
        .node.active { transform: translate(-50%, -50%) scale(1.3); background: #000; }

        @keyframes bounce { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.2); } }

    </style>
</head>
<body>

    <div class="scenery">
        <div class="cloud c1"></div>
        <div class="cloud c2"></div>
        <div class="animal horse">
            <svg viewBox="0 0 100 80"><path d="M20,70 L20,50 Q10,40 20,30 L30,10 Q40,0 50,10 L70,20 Q90,20 90,40 L90,70" fill="#5D4037"/><circle cx="40" cy="20" r="2" fill="white"/></svg>
        </div>
        <div class="animal camel">
            <svg viewBox="0 0 100 80"><path d="M10,70 L15,50 Q10,30 20,30 Q30,10 40,20 Q50,30 60,20 Q70,10 80,30 L90,50 L90,70" fill="#8D6E63"/></svg>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="game.undo()">â†© ×¦×¢×“ ××—×•×¨×”</button>
        <button class="btn" onclick="game.reset()">â†» ×”×ª×—×œ ××—×“×©</button>
    </div>

    <div id="stage">
        <div id="anchor-point">
            <div id="target-layer"></div>
            <div id="build-layer"></div>
        </div>
    </div>

    <div id="sidebar"></div>
    <div id="msg">×‘×¨×•×›×™× ×”×‘××™×! ×”×ª×—×™×œ×• ×‘×’×¨×™×¨×ª ×”×¨×¦×¤×”.</div>
    <canvas id="ropes-layer"></canvas>

    <script>
        // === SVG Assets - ××¢×•×“×›× ×™× ×œ×¤×™ ×‘×§×©×ª×š ===
        const SVGS = {
            base: `
                <svg viewBox="0 0 500 250">
                    <ellipse cx="250" cy="125" rx="240" ry="100" fill="#DEB887" stroke="#5D4037" stroke-width="4"/>
                    <path d="M130,40 Q250,60 370,40 M100,80 Q250,110 400,80 M80,125 Q250,155 420,125" stroke="#8D6E63" stroke-width="2" fill="none" opacity="0.6"/>
                </svg>`,
            
            walls: `
                <svg viewBox="0 0 520 180">
                    <defs><pattern id="lattice" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M0,0 L20,20 M20,0 L0,20" stroke="#8D6E63" stroke-width="2" fill="none"/></pattern></defs>
                    <path d="M20,60 Q260,0 500,60 L500,120 Q260,60 20,120 Z" fill="url(#lattice)" stroke="#5D4037" stroke-width="3"/>
                    <path d="M20,120 Q110,145 200,135 L200,75 Q110,85 20,60 Z" fill="url(#lattice)" stroke="#5D4037" stroke-width="3"/>
                    <path d="M500,120 Q410,145 320,135 L320,75 Q410,85 500,60 Z" fill="url(#lattice)" stroke="#5D4037" stroke-width="3"/>
                </svg>`,

            door: `
                <svg viewBox="0 0 100 160">
                    <rect x="10" y="10" width="80" height="140" fill="#B71C1C" stroke="#4A0000" stroke-width="3"/>
                    <rect x="20" y="20" width="25" height="120" fill="#D32F2F" stroke="#FFC107"/>
                    <rect x="55" y="20" width="25" height="120" fill="#D32F2F" stroke="#FFC107"/>
                    <path d="M10,40 Q50,10 90,40" stroke="#FFC107" stroke-width="3" fill="none"/>
                    <circle cx="32" cy="80" r="3" fill="gold"/>
                    <circle cx="68" cy="80" r="3" fill="gold"/>
                </svg>`,

            poles: `
                <svg viewBox="0 0 100 200">
                    <rect x="20" y="20" width="10" height="180" fill="#5D4037"/>
                    <rect x="70" y="20" width="10" height="180" fill="#5D4037"/>
                    <path d="M15,20 L35,20 L40,5 L10,5 Z" fill="#FFC107"/>
                    <path d="M65,20 L85,20 L90,5 L60,5 Z" fill="#FFC107"/>
                </svg>`,

            crown: `
                <svg viewBox="0 0 120 60">
                    <ellipse cx="60" cy="30" rx="55" ry="25" fill="none" stroke="#B71C1C" stroke-width="6"/>
                    <line x1="60" y1="5" x2="60" y2="55" stroke="#B71C1C" stroke-width="4"/>
                    <line x1="15" y1="30" x2="105" y2="30" stroke="#B71C1C" stroke-width="4"/>
                    <circle cx="60" cy="30" r="15" fill="#81D4FA"/>
                </svg>`,

            roof: `
                <svg viewBox="0 0 540 250">
                    <g stroke="#5D4037" stroke-width="2">
                        <line x1="270" y1="20" x2="20" y2="180"/>
                        <line x1="270" y1="20" x2="80" y2="200"/>
                        <line x1="270" y1="20" x2="160" y2="220"/>
                        <line x1="270" y1="20" x2="380" y2="220"/>
                        <line x1="270" y1="20" x2="460" y2="200"/>
                        <line x1="270" y1="20" x2="520" y2="180"/>
                        <ellipse cx="270" cy="20" rx="40" ry="10" fill="#B71C1C"/>
                    </g>
                </svg>`,

            // ×”××¨×›×ª×™ ××ª ×”×’×•×‘×” (360 ×‘××§×•× 350) ×›×“×™ ×œ×¨×“×ª ×¢×•×“ ×œ××˜×”
            felt: `
                <svg viewBox="0 0 580 360">
                    <defs>
                        <mask id="door-hole-felt">
                            <rect x="0" y="0" width="580" height="360" fill="white"/>
                            <ellipse cx="290" cy="40" rx="60" ry="20" fill="black"/> 
                            <rect x="245" y="210" width="90" height="150" fill="black"/>
                        </mask>
                    </defs>
                    <path d="M20,270 Q290,380 560,270 L440,50 Q290,10 140,50 Z" fill="#9E9E9E" stroke="#757575" stroke-width="2" opacity="0.95" mask="url(#door-hole-felt)"/>
                </svg>`,

            // ×”××¨×›×ª×™ ××ª ×”×’×•×‘×” (380 ×‘××§×•× 370) ×›×“×™ ×œ×¨×“×ª ×¢×•×“ ×œ××˜×”
            cover: `
                <svg viewBox="0 0 600 380">
                    <defs>
                        <mask id="door-hole-cover">
                            <rect x="0" y="0" width="600" height="380" fill="white"/>
                            <ellipse cx="300" cy="55" rx="65" ry="22" fill="black"/> 
                            <rect x="255" y="215" width="90" height="165" fill="black"/> 
                        </mask>
                        <pattern id="deco-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                            <rect width="20" height="20" fill="#B71C1C"/>
                            <path d="M0,10 L10,0 L20,10 L10,20 Z" fill="#FFC107"/>
                        </pattern>
                    </defs>
                    <g mask="url(#door-hole-cover)">
                        <!-- ×‘×“ ××¨×•×š ×‘××™×•×—×“ -->
                        <path d="M20,280 Q300,390 580,280 L450,55 Q300,15 150,55 Z" fill="#F5F5F5" stroke="#EEEEEE" stroke-width="2"/>
                        
                        <!-- ×¢×™×˜×•×¨ ×ª×—×ª×•×Ÿ ××•× ××š -->
                        <path d="M20,280 Q300,390 580,280 L570,250 Q300,360 30,250 Z" fill="url(#deco-pattern)" opacity="0.9"/>
                        
                        <path d="M150,55 L110,290" stroke="#E0E0E0" stroke-width="2" fill="none"/>
                        <path d="M450,55 L490,290" stroke="#E0E0E0" stroke-width="2" fill="none"/>
                        <path d="M300,35 L300,330" stroke="#E0E0E0" stroke-width="2" fill="none"/>
                    </g>
                </svg>`
        };

        const STEPS = [
            { id: 'floor', name: '×¨×¦×¤×”', svg: SVGS.base, w: 400, h: 200, z: 1, y: 0 },
            { id: 'walls', name: '×§×™×¨×•×ª', svg: SVGS.walls, w: 420, h: 144, z: 5, y: -20 },
            { id: 'door', name: '×“×œ×ª', svg: SVGS.door, w: 70, h: 112, z: 20, y: 15 },
            { id: 'poles', name: '×¢××•×“×™×', svg: SVGS.poles, w: 70, h: 140, z: 15, y: -20 },
            { id: 'crown', name: '×›×ª×¨', svg: SVGS.crown, w: 80, h: 40, z: 25, y: -130 },
            { id: 'roof', name: '×©×œ×“ ×’×’', svg: SVGS.roof, w: 440, h: 200, z: 22, y: -85 },
            // ×”××¨×›×” × ×•×¡×¤×ª ×‘××™×“×•×ª ×•×”× ××›×” ×©×œ ×”××™×§×•× (y)
            { id: 'felt', name: '×‘×™×“×•×“', svg: SVGS.felt, w: 480, h: 310, z: 28, y: -55 }, 
            { id: 'cover', name: '×›×™×¡×•×™', svg: SVGS.cover, w: 500, h: 330, z: 30, y: -55 }, 
            { id: 'ropes', name: '×§×©×™×¨×”', type: 'minigame' }
        ];

        class YurtGame {
            constructor() {
                this.currentStep = 0;
                this.history = [];
                this.dragEl = null;
                
                this.isDrawingRope = false;
                this.currentRopeStart = null;
                this.completedRopes = 0;
                this.ropesToComplete = 5;
                this.ropePairs = [];

                this.audioCtx = null;

                this.handleRopeDown = this.handleRopeDown.bind(this);
                this.handleRopeMove = this.handleRopeMove.bind(this);
                this.handleRopeUp = this.handleRopeUp.bind(this);

                this.initUI();
                this.updateState();
            }

            initAudio() {
                if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
            }

            playSound(type) {
                this.initAudio();
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);
                const now = this.audioCtx.currentTime;

                if (type === 'snap') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                } else if (type === 'win') {
                    osc.type = 'square';
                    [440, 554, 659].forEach((f, i) => {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g);
                        g.connect(this.audioCtx.destination);
                        o.frequency.value = f;
                        g.gain.setValueAtTime(0.1, now + i*0.1);
                        g.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                        o.start(now + i*0.1);
                        o.stop(now + 1.0);
                    });
                }
            }

            initUI() {
                const sidebar = document.getElementById('sidebar');
                sidebar.innerHTML = '';
                STEPS.forEach((step, idx) => {
                    const div = document.createElement('div');
                    div.className = 'tool locked';
                    div.id = `tool-${idx}`;
                    
                    if (step.type === 'minigame') {
                        div.innerHTML = `<span style="font-size:30px">ğŸ§¶</span><span>×§×©×™×¨×”</span>`;
                        div.onclick = () => { if (this.currentStep === idx) this.startMinigame(); };
                    } else {
                        div.innerHTML = step.svg + `<span>${step.name}</span>`;
                        div.onmousedown = (e) => this.startDrag(e, idx);
                        div.ontouchstart = (e) => this.startDrag(e, idx);
                    }
                    sidebar.appendChild(div);
                });
            }

            updateState() {
                STEPS.forEach((step, i) => {
                    const el = document.getElementById(`tool-${i}`);
                    el.className = 'tool';
                    if (i < this.currentStep) el.classList.add('done');
                    else if (i === this.currentStep) el.classList.add('active');
                    else el.classList.add('locked');
                });
                const msg = document.getElementById('msg');
                if (this.currentStep < STEPS.length) {
                    msg.innerText = `×©×œ×‘ ${this.currentStep + 1}: ×’×¨×¨×• ××ª ×”${STEPS[this.currentStep].name}`;
                } else {
                    msg.innerText = "×”×™×•×¨×˜×” ××•×›× ×”!";
                }
            }

            startDrag(e, idx) {
                if (idx !== this.currentStep) return;
                e.preventDefault();
                this.initAudio();
                const touch = e.touches ? e.touches[0] : e;
                this.dragEl = document.createElement('div');
                this.dragEl.className = 'drag-ghost';
                this.dragEl.innerHTML = STEPS[idx].svg;
                this.updateDragPos(touch.clientX, touch.clientY);
                document.body.appendChild(this.dragEl);
                this.showDropTarget(idx);

                const moveHandler = (ev) => {
                    ev.preventDefault();
                    const t = ev.touches ? ev.touches[0] : e;
                    this.updateDragPos(t.clientX, t.clientY);
                    this.checkHover(t.clientX, t.clientY);
                };
                const upHandler = (ev) => {
                    const t = ev.changedTouches ? ev.changedTouches[0] : ev;
                    this.checkDrop(t.clientX, t.clientY, idx);
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', upHandler);
                    document.removeEventListener('touchmove', moveHandler);
                    document.removeEventListener('touchend', upHandler);
                    if (this.dragEl) this.dragEl.remove();
                    this.hideDropTarget();
                };
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
                document.addEventListener('touchmove', moveHandler, {passive: false});
                document.addEventListener('touchend', upHandler);
            }

            updateDragPos(x, y) {
                if (this.dragEl) {
                    this.dragEl.style.left = x + 'px';
                    this.dragEl.style.top = y + 'px';
                }
            }

            showDropTarget(idx) {
                const layer = document.getElementById('target-layer');
                layer.innerHTML = '';
                const step = STEPS[idx];
                const target = document.createElement('div');
                target.className = 'drop-target active';
                target.style.width = (step.w * 0.5) + 'px';
                target.style.height = (step.h * 0.5) + 'px';
                target.style.marginTop = step.y + 'px';
                layer.appendChild(target);
            }

            hideDropTarget() { document.getElementById('target-layer').innerHTML = ''; }
            
            checkHover(x, y) {
                const target = document.querySelector('.drop-target');
                if (!target) return;
                const rect = target.getBoundingClientRect();
                if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) target.classList.add('hover');
                else target.classList.remove('hover');
            }

            checkDrop(x, y, idx) {
                const target = document.querySelector('.drop-target');
                if (!target) return;
                const rect = target.getBoundingClientRect();
                if (x > rect.left - 50 && x < rect.right + 50 && y > rect.top - 50 && y < rect.bottom + 50) {
                    this.placePart(idx);
                }
            }

            placePart(idx) {
                const step = STEPS[idx];
                const layer = document.getElementById('build-layer');
                const part = document.createElement('div');
                part.className = 'part visible';
                part.innerHTML = step.svg;
                part.style.width = step.w + 'px';
                part.style.height = step.h + 'px';
                part.style.zIndex = step.z;
                part.style.marginTop = step.y + 'px';
                layer.appendChild(part);
                this.playSound('snap');
                this.history.push(part);
                this.currentStep++;
                this.updateState();
            }

            undo() {
                if (this.history.length === 0) return;
                const part = this.history.pop();
                part.remove();
                this.currentStep--;
                this.clearMinigame();
                this.updateState();
            }

            reset() {
                if (!confirm("×œ××¤×¡ ××ª ×”××©×—×§?")) return;
                const layer = document.getElementById('build-layer');
                while (layer.firstChild) layer.removeChild(layer.firstChild);
                this.history = [];
                this.currentStep = 0;
                this.clearMinigame();
                this.updateState();
            }

            // === ××™× ×™-×’×™×™× ×—×‘×œ×™× ××©×•×¤×¨ ===
            startMinigame() {
                this.initAudio();
                const msg = document.getElementById('msg');
                msg.innerText = "××ª×—×• ×—×‘×œ×™× ×©×—×•×¨×™× ××”×—×œ×§ ×”×¢×œ×™×•×Ÿ ×œ×ª×—×ª×™×ª ×”×™×•×¨×˜×”!";
                
                const canvas = document.getElementById('ropes-layer');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                // 5 ×—×‘×œ×™×
                // × ×§×•×“×•×ª ×”×§×™×¦×•×Ÿ ×”×•×–×–×• ×¤× ×™××” (26% ×•-74%) ×‘××§×•× (20% ×•-80%)
                const pairs = [
                    { start: {x: '50%', y: '30%'}, end: {x: '50%', y: '58%'}, curve: 0 },
                    { start: {x: '45%', y: '30%'}, end: {x: '35%', y: '68%'}, curve: -60 },
                    { start: {x: '40%', y: '30%'}, end: {x: '26%', y: '65%'}, curve: -80 }, // ×©×××œ ×§×™×¦×•× ×™ ××•×¦××“
                    { start: {x: '55%', y: '30%'}, end: {x: '65%', y: '68%'}, curve: 60 },
                    { start: {x: '60%', y: '30%'}, end: {x: '74%', y: '65%'}, curve: 80 }  // ×™××™×Ÿ ×§×™×¦×•× ×™ ××•×¦××“
                ];

                this.ropeNodes = [];
                this.ropePairs = [];
                this.completedRopes = 0;

                pairs.forEach((pair, i) => {
                    const startNode = this.createNode(pair.start.x, pair.start.y, 'start', i);
                    const endNode = this.createNode(pair.end.x, pair.end.y, 'end', i);
                    this.ropePairs.push({ start: startNode, end: endNode, completed: false, curve: pair.curve });
                });

                document.addEventListener('mousedown', this.handleRopeDown);
                document.addEventListener('touchstart', this.handleRopeDown, {passive: false});
            }

            createNode(x, y, type, index) {
                const node = document.createElement('div');
                node.className = `node ${type}`;
                node.style.left = x;
                node.style.top = y;
                node.dataset.index = index;
                node.dataset.type = type;
                document.body.appendChild(node);
                this.ropeNodes.push(node);
                return node;
            }

            handleRopeDown(e) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('node') && target.dataset.type === 'start') {
                    const index = parseInt(target.dataset.index);
                    if (!this.ropePairs[index].completed) {
                        this.isDrawingRope = true;
                        this.currentRopeStart = target;
                        target.classList.add('active');
                        document.addEventListener('mousemove', this.handleRopeMove);
                        document.addEventListener('mouseup', this.handleRopeUp);
                        document.addEventListener('touchmove', this.handleRopeMove, {passive: false});
                        document.addEventListener('touchend', this.handleRopeUp);
                    }
                }
            }

            handleRopeMove(e) {
                e.preventDefault();
                if (!this.isDrawingRope) return;
                const touch = e.touches ? e.touches[0] : e;
                this.drawTempRope(touch.clientX, touch.clientY);
            }

            handleRopeUp(e) {
                e.preventDefault();
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (this.isDrawingRope) {
                    const startIndex = parseInt(this.currentRopeStart.dataset.index);
                    if (target && target.classList.contains('node') && target.dataset.type === 'end' && parseInt(target.dataset.index) === startIndex) {
                        this.ropePairs[startIndex].completed = true;
                        this.completedRopes++;
                        this.currentRopeStart.style.visibility = 'hidden';
                        target.style.visibility = 'hidden';
                        this.playSound('snap');
                        this.redrawCompletedRopes();
                        if (this.completedRopes >= this.ropesToComplete) setTimeout(() => this.finishGame(), 500);
                    } else {
                        this.currentRopeStart.classList.remove('active');
                        this.redrawCompletedRopes();
                    }
                }
                this.isDrawingRope = false;
                this.currentRopeStart = null;
                document.removeEventListener('mousemove', this.handleRopeMove);
                document.removeEventListener('mouseup', this.handleRopeUp);
                document.removeEventListener('touchmove', this.handleRopeMove);
                document.removeEventListener('touchend', this.handleRopeUp);
            }

            drawTempRope(x, y) {
                this.redrawCompletedRopes();
                const canvas = document.getElementById('ropes-layer');
                const ctx = canvas.getContext('2d');
                const startRect = this.currentRopeStart.getBoundingClientRect();
                
                ctx.beginPath();
                ctx.moveTo(startRect.left + startRect.width/2, startRect.top + startRect.height/2);
                
                // ×—×™×©×•×‘ ×¢×§×•××”
                const index = parseInt(this.currentRopeStart.dataset.index);
                const curveOffset = this.ropePairs[index].curve; 
                
                const midX = (startRect.left + startRect.width/2 + x) / 2;
                const midY = (startRect.top + startRect.height/2 + y) / 2;
                
                ctx.quadraticCurveTo(midX + curveOffset, midY, x, y);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
            }

            redrawCompletedRopes() {
                const canvas = document.getElementById('ropes-layer');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.ropePairs.forEach(pair => {
                    if (pair.completed) {
                        const r1 = pair.start.getBoundingClientRect();
                        const r2 = pair.end.getBoundingClientRect();
                        ctx.beginPath();
                        const startX = r1.left + r1.width/2;
                        const startY = r1.top + r1.height/2;
                        const endX = r2.left + r2.width/2;
                        const endY = r2.top + r2.height/2;
                        
                        ctx.moveTo(startX, startY);
                        
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        
                        ctx.quadraticCurveTo(midX + pair.curve, midY, endX, endY);
                        
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 4;
                        ctx.setLineDash([]);
                        ctx.stroke();
                    }
                });
            }

            clearMinigame() {
                if (this.ropeNodes) { this.ropeNodes.forEach(n => n.remove()); this.ropeNodes = []; }
                const canvas = document.getElementById('ropes-layer');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                document.removeEventListener('mousedown', this.handleRopeDown);
                document.removeEventListener('touchstart', this.handleRopeDown);
                this.ropePairs = [];
                this.completedRopes = 0;
            }

            finishGame() {
                this.clearMinigame();
                const msg = document.getElementById('msg');
                msg.innerText = "ğŸ‰ ×›×œ ×”×›×‘×•×“! ×”×™×•×¨×˜×” ××•×›× ×”! ğŸ‰";
                msg.style.background = "#FFC107"; msg.style.color = "black";
                this.playSound('win');
                this.launchConfetti();
            }

            launchConfetti() {
                for(let i=0; i<60; i++) {
                    const c = document.createElement('div');
                    c.style.position = 'absolute'; c.style.width='10px'; c.style.height='10px';
                    c.style.background = ['#fff','#FFC107','#F44336'][Math.floor(Math.random()*3)];
                    c.style.left = Math.random()*100+'vw'; c.style.top = -10+'px';
                    document.body.appendChild(c);
                    c.animate([
                        { transform: 'translate(0,0) rotate(0deg)', opacity: 1 },
                        { transform: `translate(${Math.random()*100-50}px, 100vh) rotate(720deg)`, opacity: 0 }
                    ], { duration: 1500+Math.random()*1500 }).onfinish = () => c.remove();
                }
            }
        }

        const game = new YurtGame();
    </script>
</body>
</html>
